#include <cmath>
#include <fstream>
#include <algorithm>
#include <vector>
#include <numbers>
#include <numeric>
#include <gsl/gsl_interp.h>
#include <gsl/gsl_errno.h>
#include <chrono>

#include "Type299_functions.h"
#include "Type299_loadAggregation.h"
#include "Type299_gfunctions.h"
#include <TRNSYS.h> //TRNSYS acess functions (allow to acess TIME etc.)

//#define LOG_PERFORMANCE

const bool debugMode = false;
const double pi = std::numbers::pi;

// Object: Borehole heat exchanger field
// Simulation Studio Model: Type299
// 

// Author: Xenia Kirschstein
// Editor: 
// Date:	 November 29, 2024
// last modified: November 29, 2024

// *** 
// *** Model Inputs 
// *** 
//			Inlet fluid temperature	C [-273.15;+6000]
//			Inlet mass flow rate (total)	kg/hr [0;+Inf]

// *** 
// *** Model Outputs 
// *** 
//			Outlet temperature	C [-273.15;6000]
//			Outlet mass flow rate (total)	kg/hr [0;+Inf]
//			Average wall temperature	C [-273.15;6000]
//			Average heat transfer rate	kJ/hr [-Inf;+Inf]

// *** 
// *** Model Derivatives 
// *** 

// (Comments and routine interface generated by TRNSYS Simulation Studio)
//************************************************************************

// static parameters

	static int n_Utubes{0}; // Number of U-tubes per borehole	- [1;2]
	static double l_BHE{0.}; // Length of one borehole	m [10;+Inf]
	static double r_BHE{0.}; // Borehole radius	m [0;+Inf]
	static double r_tube{0.}; // Tube radius	m [0;+Inf]
	static double lambda_tube{0.}; // TC tube	kJ/hr.m.K [0;+Inf]
	static double d_tube{0.}; // Tube wall thickness	m [0;+Inf]
	static double d_shanks{0.}; // Shank spacing from centre of U-tube to centre of borehole	m [0;+Inf]
	static double lambda_ground{0.}; // TC ground	kJ/hr.m.K [0;+Inf]
	static double rho_ground{0.}; // Density ground	kg/m^3 [0;+Inf]
	static double c_ground{0.}; // cground	kJ/kg.K [0;+Inf]
	static double lambda_grout{0.}; // TC filling	kJ/hr.m.K [0;+Inf]
	static double rho_grout{0.}; // Density filling	kg/m^3 [0;+Inf]
	static double c_grout{0.}; // Specific heat capacity of filling	kJ/kg.K [0;+Inf]
	static int n_seg{0}; // Number of segments	- [2;+Inf]
	static double lambda_HTM{0.}; // TC fluid	kJ/hr.m.K [0;+Inf]
	static double rho_HTM{0.}; // Density fluid	kg/m^3 [0;+Inf]
	static double c_HTM{0.}; // Specific heat capacity of fluid	kJ/kg.K [0;+Inf]
	static double mu_HTM{0.}; // dynamic viscosity of the fluid kg/m/h [0;+Inf]
	static double temp_undisturbed{0.}; // Undisturbed ground temperature	C [-273.15;6000]
	static double temp_init{0.}; // Initial BHE temperature	C [-273.15;6000]
	static int n_g{0}; // Number of sheath grout nodes	- [2;+Inf]

	static double timestep{0.}; // simulation time step size (s)
	static double timeSpan{0.}; // t_simEnd - t_simStart (s)

	static double ri_tube{0.}; // inner radius of one pipe
	static double area_tube{0.}; // area of the inner cross section of one pipe
	static double nu_HTM{0.}; // kinematic viscosity of the fluid kg*m3*h/(kg*m*h*3600s) -> m2/s
	static double a_HTM{0.}; // thermal diffusivity kJ*m3*kg*K*h/(h*m*K*kg*kJ*3600s) -> m2/s
	static int n_pipes{0}; // number of pipes = 2*n_Utubes

	static double cvol_ground{0.}; // volumetric heat capacity (J/m3/K)
	static double res_p{0.}; // conductive resistance of the pipe material (K*m/W)
	static double l_seg{0.}; // length of one BHE vertical element (m)
	static double vol_pipeSeg{0.}; // volume of one pipe vertical element (m3/m)
	static double cap_HTMseg{0.}; // thermal capacity of one fluid segement (J/K/m)
	static double vol_ggTot{0.}; // total volume of the core grout (m3/m)
	static double r_gInner{0.}; // inner radius of the sheath grout (m)
	static double res_g{0.};
	static double res_gg1{0.};
	static double res_gg2{0.};
	static double res_gj{0.}; // sheath grout resistance of a single node (m*K/W)

	static int n_BHE{1}; // number of borehole heat exchangers
	static Eigen::VectorXd dg; // thermal response factor increments (m*K/W)
    static Eigen::RowVectorXd q_b; // heat extraction rate per m BHE (W/m) 
    static Eigen::MatrixXd A; // matrix for time shifting of aggregated loads

	static std::vector<int> iSupTemp; // location of supply temperature in the dynamic array
	static std::vector<int> iRetTemp; // location of return temperature in the dynamic array
	static std::vector<int> iTempWall; // location of g-function interface temperature in the dynamic array
	static std::vector<double> storageBetweenTimesteps; // array to store values between timesteps
	static std::vector<double> storageWithinTimestep; // array to store values between sub-timesteps

void readParameters()
{
	int index = 1;  n_Utubes = static_cast<int>(getParameterValue(&index));
	index = 2;  l_BHE = getParameterValue(&index);
	index = 3;  r_BHE = getParameterValue(&index);
	index = 4;  r_tube = getParameterValue(&index);
	index = 5;  lambda_tube = getParameterValue(&index)/3.6; // W/m/K
	index = 6;  d_tube = getParameterValue(&index);
	index = 7;  d_shanks = getParameterValue(&index);
	index = 8;  lambda_ground = getParameterValue(&index)/3.6; // W/m/K
	index = 9;  rho_ground = getParameterValue(&index);
	index = 10; c_ground = getParameterValue(&index)*1000; // J/kg/K
	index = 11; lambda_grout = getParameterValue(&index)/3.6; // W/m/K
	index = 12; rho_grout = getParameterValue(&index);
	index = 13; c_grout = getParameterValue(&index)*1000; // J/kg/K
	index = 14; n_seg = static_cast<int>(getParameterValue(&index));
	index = 15; lambda_HTM = getParameterValue(&index)/3.6; // W/m/K
	index = 16; rho_HTM = getParameterValue(&index);
	index = 17; c_HTM = getParameterValue(&index)*1000; // J/kg/K
	index = 18; mu_HTM = getParameterValue(&index)/3600; // kg/m/s
	index = 19; temp_undisturbed = getParameterValue(&index)+273.15; // K
	//index = 22; temp_init = getParameterValue(&index)+273.15; // K
	index = 20; n_g = static_cast<int>(getParameterValue(&index));
	index = 21; int read_gFuncFromFile = getParameterValue(&index);
	// global Trnsys parameters
	timestep = getSimulationTimeStep()*3600; // s
	double t_simEnd = getSimulationStopTime()*3600; // s
	double t_simStart = getSimulationStartTime()*3600; // s
	timeSpan = t_simEnd - t_simStart;
	// other time independent parameters
	ri_tube = r_tube - d_tube;
	area_tube = pi*pow(ri_tube,2);
	nu_HTM = mu_HTM/rho_HTM; 
	a_HTM = lambda_HTM/rho_HTM/c_HTM;
	n_pipes = 2*n_Utubes;
	l_seg = l_BHE/n_seg;
	temp_init = temp_undisturbed;
	// thermal resistances and capacities
	cvol_ground = c_ground*rho_ground;
	res_p = std::log(r_tube/ri_tube)/(2*pi*lambda_tube);
	r_gInner = pow(3*pow(r_tube,2) + 2*pow(d_shanks,2)/pi,0.5); // only valid for 2U!
	vol_pipeSeg = pi*pow(ri_tube,2);
	cap_HTMseg = rho_HTM*vol_pipeSeg*c_HTM;
	vol_ggTot = (2*pow(d_shanks,2) - pi*pow(r_tube,2)); // only valid for 2U!
	// simulation
	iSupTemp.resize(n_seg);
	iRetTemp.resize(n_seg);
	iTempWall.resize(n_seg);
	for(int iSeg=0; iSeg<n_seg; iSeg++)
	{
		iSupTemp[iSeg] = iSeg*(3+2*n_g) +1;
		iRetTemp[iSeg] = iSupTemp[iSeg] + 1;
		iTempWall[iSeg] = iRetTemp[iSeg] + 1;
	}
	int nStore = 1+(3+2*n_g)*n_seg;
	storageBetweenTimesteps.resize(nStore,temp_init);
	storageWithinTimestep.resize(nStore,temp_init);
	// read external file containing borehole coordinates
	std::string fileNameCoord = "./coordinates.txt"; // Must currently be placed in the project folder
		
	std::ifstream file(fileNameCoord);
	if (!file.is_open())
	{
		t299::message("fatal","file containing the borehole coordinates couldn't be opened."
		" Please place 'coordinates.txt' in the same folder as the .dck file.");
	}
	double xValue, yValue;
	std::vector<double> tempX, tempY;
	tempX.reserve(100);
	tempY.reserve(100);
    file.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Skip the first line
    while (file >> xValue >> yValue)
	{
        tempX.push_back(xValue);
        tempY.push_back(yValue);
        file.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Ignore further columns
    }
	// vectors with x- and y-coordinates of boreholes
	Eigen::Map<Eigen::VectorXd> xCoor(tempX.data(), tempX.size());
    Eigen::Map<Eigen::VectorXd> yCoor(tempY.data(), tempY.size());

    file.close();
	file.clear();
	// load aggregation
	n_BHE = xCoor.size();
	// TODO make cells_per_level a Studio parameter
    int cells_per_level = 5; // number of load aggregation cells per level (cell widths double every cells_per_level cells)
	Eigen::VectorXd time_values = loadAgg::time_ClaessonJaved(timestep,timeSpan,cells_per_level); // growing time for loadAgg (h)
	int nt_gd = time_values.size(); // number of (growing) time values for thermal response factors
	Eigen::VectorXd diff = (time_values.tail(nt_gd-1) - time_values.head(nt_gd-1)) / timestep;
	Eigen::VectorXd width(diff.size() + 1); // Load aggregation cell widths
    width(0) = 1.;
    width.tail(diff.size()) = diff;
	// g-function
	Eigen::VectorXd g_borefield;
	if(read_gFuncFromFile>0)
	{
		// read external file containing borehole coordinates
		std::string fileNameGfunc = "./pygfunction_gFunc.txt";
		std::ifstream file2(fileNameGfunc);
		if(!file2.is_open())
		{
			t299::message("fatal","file containing the g-function couldn't be opened."
			" Please place 'pygfunction_gFunc.txt' in the same folder as the .dck file.");
		}
		std::string line;
		std::vector<double> gFunc_fromFile;
		while(std::getline(file2, line))
		{ // g-function lines are text for some reason
			gFunc_fromFile.push_back(stold(line));
		}
		g_borefield = Eigen::Map<Eigen::VectorXd>(gFunc_fromFile.data(), gFunc_fromFile.size());
		file2.close();

	}
	else
		g_borefield = gFunc::g_Borefield(xCoor,yCoor,time_values,r_BHE,l_BHE,lambda_ground,cvol_ground); // g-function of the BHE field
	dg = loadAgg::initialize_dg(g_borefield,lambda_ground);
    q_b.resize(nt_gd);
	q_b.setZero();
    A = loadAgg::initialize_A(width); // Matrix for time shifting of aggregated loads
	double dT_init = temp_init - temp_undisturbed; // initial temperature drop (K)
	// Set initial state TODO make independent from simulation period
	double q_history = dT_init/dg(nt_gd-1); // lumped past load which leads to dT_init
	q_b(nt_gd-1) = q_history;
} // end of calculations only done at start time

// ---------------------- Here the Type starts ----------------------
extern "C" __declspec(dllexport) void TYPE299(void)
{
//Variable Declarations

//    INPUTS
	double temp_in; //Inlet_fluid_temperature;
	double mflow_in; //Inlet_mass_flow_rate__total_;

	// Trnsys auxiliary variables
	double zeroD = 0.;
	int index;
	char type[20];
	char message[400];

	//Get the Global Trnsys Simulation Variables
	double time = getSimulationTime();

	//Set the Version Number for This Type
	if (getIsVersionSigningTime())
	{
		int v = 17;
		setTypeVersion(&v);
		return;
	}

	//Do All of the Last Call Manipulations Here
	if (getIsLastCallofSimulation())
	{
		return;
	}

	//Perform Any "End of Timestep" Manipulations That May Be Required
	if (getIsEndOfTimestep()) 
	{
        //TODO: write SSR values, if any
        //if (getIsIncludedInSSR())
		//{
		//	double outval=42;
		//	index = 1;
		//	updateReportIntegral(&index, &outval);
        //  ...
        //}
	}

	//Do All of the "Very First Call of the Simulation Manipulations" Here
	if (getIsFirstCallofSimulation())
	{
		// Turn off gsl default error handler that would kill the entire application on error 
		gsl_set_error_handler_off();

		//Tell the TRNSYS Engine How This Type Works
		int npar = 21;
		int nin = 2;
		int nder = 0;
		int nout = 4;
		int mode = 1;
		int staticStore = 0;
		int dynamicStore = 0; //10300; // 0 + (VL + RL + wall + 2*ng_max) * nseg_max // (-> 3 + 2*ng per slice)

		setNumberofParameters(&npar);
		setNumberofInputs(&nin);
		setNumberofDerivatives(&nder);
		setNumberofOutputs(&nout);
		setIterationMode(&mode);
		setNumberStoredVariables(&staticStore, &dynamicStore);

		return;
	}

	//Do All of the "Start Time" Manipulations Here - There Are No Iterations at the Initial Time
	if (getIsStartTime())
	{
		readParameters();

		//Check the Parameters for Problems
		if(temp_undisturbed <= 0.)
		{
			index = 20;
			strcpy_s(type, "Warning");
			strcpy_s(message, "Are you sure the undisturbed ground temperature should be below zero degC?");
			foundBadParameter(&index, type, message, (size_t)strlen(type), (size_t)strlen(message));
		}
        
		//Read in the Values of the Inputs from the Input File
		index = 1; temp_in = getInputValue(&index)+273.15; // K
		index = 2; mflow_in = getInputValue(&index)/3600; // kg/s

		double tempUndisturbed_stupidUnits = temp_undisturbed - 273.15;
		double temp_init_stupidUnits = temp_init - 273.15;
		double mflowIn_stupidUnits = mflow_in*3600;

		//Set the Initial Values of the Outputs
		index = 1; setOutputValue(&index, &temp_init_stupidUnits); // Outlet temperature in degC
		index = 2; setOutputValue(&index, &mflowIn_stupidUnits); // Outlet mass flow rate (total) in kg/h
		index = 3; setOutputValue(&index, &temp_init_stupidUnits); // Average wall temperature in degC
		index = 4; setOutputValue(&index, &zeroD); // Average heat transfer rate in kJ/h
		
		//TODO: Initialize SSR report variables, if any
		//if (getIsIncludedInSSR())
		//{
		//	index = 1;
		//	char desc[100], unit1[5], unit2[5];
		//	strcpy_s(desc, "Energy to Fluid");
		//	strcpy_s(unit1, "kJ/h");
		//	strcpy_s(unit2, "kJ");
		//	initReportIntegral(&index, desc, unit1, unit2, (size_t)strlen(desc), (size_t)strlen(unit1), (size_t)strlen(unit2));
        //  ...        
		//}

		return;
	}

//---------------------------------------------------------------------------------------------------------------------- -
	//ReRead the Parameters if Another Unit of This Type Has Been Called Last
	/*if (getIsReReadParameters()) // If needed the calculations from parameters should be stored!!!
	{
		readParameters();
	//return;
	}*/

	//Get the Current Inputs to the Model
	index = 1; temp_in = getInputValue(&index)+273.15; // K
	index = 2; mflow_in = getInputValue(&index)/3600; // kg/s

	if(temp_in > 200+273.15)
	{
		index = 1;
		strcpy_s(type, "Fatal");
		strcpy_s(message, "BHE inlet temperature is above 200 degC. Please don't cook the ground.");
		foundBadInput(&index, type, message, (size_t)strlen(type), (size_t)strlen(message));
	}

	if(mflow_in > 3./1000.*rho_HTM*n_BHE*n_Utubes)
	{
		index = 2;
		strcpy_s(type, "Warning");
		strcpy_s(message, "BHE inlet mass flow rate is above 3 L/s per tube.");
		foundBadInput(&index, type, message, (size_t)strlen(type), (size_t)strlen(message));
	}

//---------------------------------------------------------------------------------------------------------------------- -
//Perform All of the Calculations Here
	auto currentTime = std::chrono::steady_clock::now();
	auto logTime = [&](std::string&& timeBlockName)
	{
		#ifdef LOG_PERFORMANCE
		auto endTime = std::chrono::steady_clock::now();
		auto timeDiff = std::chrono::duration<double,std::milli>(endTime - currentTime).count();
		t299::message("notice",("time for " + timeBlockName +": " + std::to_string(timeDiff) + " ms").c_str());
		currentTime = std::chrono::steady_clock::now();
		#endif
	};
	int iIteration = getTimestepIteration();

	// ------------------------ TRCM ------------------------
	// Calculate flow properties
	double v_HTM = mflow_in/n_BHE/n_Utubes/rho_HTM/area_tube; // fluid velocity (m/s)
	double re = v_HTM*2*r_tube/nu_HTM; // Reynolds number (-)
	double pr = nu_HTM/a_HTM; // Prandtl number (-)
	double nu = t299::calcNusseltNo(re,pr); // Nusselt number (-)
	// Calculate resistances varying with time
	double res_f = 1/(pi*nu*lambda_HTM); // convective fluid resistance in m*K/W
	double res_fp = res_f + res_p; // combined convective and conductive fluid/pipe resistance

	logTime("flow resistance");

	auto [res_g,res_gg1,res_gg2] = t299::calcGroutResistances(res_fp, lambda_grout, lambda_ground, r_BHE, r_tube, d_shanks, n_pipes); // borehole resistance Rb and inner borehole resistance Ra (m*K/W)
	res_gj = res_g/n_g;
	// Calculate heat capacities
	std::vector<double> r_g(n_g+1,0.); // radii of sheath grout nodes (m)
	std::vector<double> vol_g(n_g,0.); // volumes of sheath grout nodes (m3/m)
	std::vector<double> cap_g(n_g,0.); // thermal capacities of sheath grout nodes (J/K/m)
	r_g[0] = r_gInner;
	double lambda_grout_eq = std::log(r_BHE/r_gInner)/(2*pi*res_g);
	for(int i=0; i<n_g; i++)
	{
		r_g[i+1] = r_g[i]*exp(2.*pi*lambda_grout_eq*res_gj);
		vol_g[i] = pi*(pow(r_g[i+1],2) - pow(r_g[i],2))/n_pipes;
	}
	cap_g[0] = rho_grout*c_grout*(0.5*vol_g[0] + vol_ggTot/n_pipes); // thermal capacity of the inner grout node close to pipe (J/K/m)
	double cap_gWall = 0.5*rho_grout*c_grout*vol_g[n_g-1]; // lumped thermal capacity of the outer (wall) grout node (J/K/m)
	for(int i=1; i<n_g; i++)
		cap_g[i] = 0.5*rho_grout*c_grout*(vol_g[i-1] + vol_g[i]);
	/*else (n_g==1)
	{
		cap_g[0] = rho_grout*c_grout*(vol_g[0] + vol_ggTot/n_pipes);
	}*/
	
	logTime("grout resistance and capacity");

	if constexpr(debugMode)
	{
		double capTot = (std::reduce(cap_g.begin(), cap_g.end(),0.) + cap_gWall)*n_pipes;
		double capTotCalc = pi*(pow(r_BHE,2)-n_pipes*pow(r_tube,2))*rho_grout*c_grout;
		if(std::abs(capTot - capTotCalc) > 1.e-6)
			t299::message("fatal","Sum of thermal sub-capacities differs from total thermal capacity!");
		double volTot = (std::reduce(vol_g.begin(), vol_g.end(),0.)*n_pipes + vol_ggTot);
		double volTotCalc = pi*(pow(r_BHE,2)-n_pipes*pow(r_tube,2));
		if(std::abs(volTot - volTotCalc) > 1.e-6)
			t299::message("fatal","Sum of sub-volumes differs from total volume!");
		if(std::abs(r_g[n_g] - r_BHE) > 1.e-6)
			t299::message("fatal","Outer sub-radius does not correspond to borehole radius!");
	}
	
	currentTime = std::chrono::steady_clock::now();

	// --- Calculate temperatures in the fluid and grout ---
	double temp_out = temp_init; // BHE outlet temperature
	double tstep_max = timestep;
	// internal time step
	if(v_HTM>0.)
		tstep_max = 1.*l_seg/v_HTM; // maximum internal time step (s) for Courant number = 1.
	int n_timesteps_internal = ceil(timestep/tstep_max); // number of internal sub-timesteps
	double timestep_internal = timestep/n_timesteps_internal; // length of internal sub-timestep (s)
		
	double circ_HTMseg = mflow_in/n_BHE/n_Utubes/rho_HTM/vol_pipeSeg; // circulation of fluid segment (m/s)
	double auxFluid = l_seg/res_fp/cap_HTMseg; // (m/s)
	double af = -circ_HTMseg - auxFluid; // First part of fluid temperature ODE

	logTime("pre-calc. fluid and grout temp.");
	
	if(iIteration==0) // Temperatures of the last iteration of the last timestep are stored
		storageBetweenTimesteps = storageWithinTimestep; // (supply, return, wall, ng*grout supply, ng*grout return) per vertical slice
	else // temperatures of the last timestep are start values for each iteration
		storageWithinTimestep = storageBetweenTimesteps;
	logTime("read trnsys array.");

	for(int iTimestep=0; iTimestep<n_timesteps_internal; iTimestep++) // time step is sub-divided
	{
		for(int iSeg=0; iSeg<n_seg; iSeg++)
		{
			int iCurrSupCgpgg = iTempWall[iSeg] + 1; // location of current supply Cgpgg temperature in the dynamic array
			int iCurrRetCgpgg = iCurrSupCgpgg + n_g; // location of current return Cgpgg temperature in the dynamic array
			
			// calculate fluid return temperature
			double bfRet, bfSup;
			int iSegNext = iSeg+1;
			int iSegLast = iSeg-1;

			if(iSeg==0) // top: inlet
			{
				bfSup = circ_HTMseg*temp_in + auxFluid*storageWithinTimestep[iCurrSupCgpgg];
				bfRet = circ_HTMseg*storageWithinTimestep[iRetTemp[iSegNext]] + auxFluid*storageWithinTimestep[iCurrRetCgpgg];
			}
			else if(iSeg==n_seg-1) // bottom: connect supply and return
			{
				bfSup = circ_HTMseg*storageWithinTimestep[iSupTemp[iSegLast]] + auxFluid*storageWithinTimestep[iCurrSupCgpgg];
				bfRet = circ_HTMseg*storageWithinTimestep[iSupTemp[iSeg]] + auxFluid*storageWithinTimestep[iCurrRetCgpgg];
			}
			else
			{
				bfSup = circ_HTMseg*storageWithinTimestep[iSupTemp[iSegLast]] + auxFluid*storageWithinTimestep[iCurrSupCgpgg];
				bfRet = circ_HTMseg*storageWithinTimestep[iRetTemp[iSegNext]] + auxFluid*storageWithinTimestep[iCurrRetCgpgg];
			}
			logTime("fluid temp.");

			// -- calculate grout temperatures --
				for(int ig=0; ig<n_g; ++ig) // iterate over sheath grout nodes from fluid to wall
				{
					int iCurrSup = iCurrSupCgpgg + ig; // location of current supply grout node temperature in the dynamic array
					int iCurrRet = iCurrRetCgpgg + ig; // location of current return grout node temperature in the dynamic array
					double ag, bgSup, bgRet; //temp_GroutSupEnd, temp_GroutSupAve, temp_GroutRetEnd, temp_GroutRetAve;
					double inv_cap = 1./cap_g[ig];
					if(ig==0) // grout temperature at node close to pipe/fluid ! only for diagonal inlet pipes !
					{
						/*if(n_g==1)
						{
							double ag =-inv_cap*(1./res_fp + 1./res_gj + 2./res_gg1 + 1./res_gg2);
							double bgSup = inv_cap*(storageWithinTimestep[iSupTemp[iSeg]]/res_fp + storageWithinTimestep[iTempWall[iSeg]]/res_gj + (2.*storageWithinTimestep[iCurrRetCgpgg]/res_gg1 + storageWithinTimestep[iCurrSupCgpgg]/res_gg2));
							double bgRet = inv_cap*(storageWithinTimestep[iSupTemp[iSeg]]/res_fp + storageWithinTimestep[iTempWall[iSeg]]/res_gj + (storageWithinTimestep[iCurrRetCgpgg]/res_gg2 + 2.*storageWithinTimestep[iCurrSupCgpgg]/res_gg1));
						}*/
						int iNextSupCurr = iCurrSup+1;
						int iNextRetCurr = iCurrRet+1;
						ag =-inv_cap*(1./res_fp + 1./res_gj + 2./res_gg1 + 1./res_gg2);
						bgSup = inv_cap*(storageWithinTimestep[iSupTemp[iSeg]]/res_fp + storageWithinTimestep[iNextSupCurr]/res_gj + (2.*storageWithinTimestep[iCurrRetCgpgg]/res_gg1 + storageWithinTimestep[iCurrSupCgpgg]/res_gg2));
						bgRet = inv_cap*(storageWithinTimestep[iRetTemp[iSeg]]/res_fp + storageWithinTimestep[iNextRetCurr]/res_gj + (storageWithinTimestep[iCurrRetCgpgg]/res_gg2 + 2.*storageWithinTimestep[iCurrSupCgpgg]/res_gg1));
					}
					else if (ig==n_g-1) // grout temperature close to BHE wall
					{
						int iLastSupCurr = iCurrSup-1;
						int iLastRetCurr = iCurrRet-1;
						double inv_caps = 1./(cap_g[ig]+cap_gWall);
						ag = (-inv_cap-inv_caps)/res_gj;
						bgSup = (inv_cap*storageWithinTimestep[iLastSupCurr] + inv_caps*storageWithinTimestep[iTempWall[iSeg]])/res_gj;
						bgRet = (inv_cap*storageWithinTimestep[iLastRetCurr] + inv_caps*storageWithinTimestep[iTempWall[iSeg]])/res_gj;
					}
					else // grout temperatures between pipe and wall
					{
						int iNextSupCurr = iCurrSup+1;
						int iNextRetCurr = iCurrRet+1;
						int iLastSupCurr = iCurrSup-1;
						int iLastRetCurr = iCurrRet-1;
						ag =-inv_cap*2./res_gj;
						bgSup = inv_cap*(storageWithinTimestep[iLastSupCurr] + storageWithinTimestep[iNextSupCurr])/res_gj;
						bgRet = inv_cap*(storageWithinTimestep[iLastRetCurr] + storageWithinTimestep[iNextRetCurr])/res_gj;
					}
					logTime("grout temp");
					
					// Grout temperature next sub-timestep
					storageWithinTimestep[iCurrSup] = t299::solveDiffEqIntern_end(ag,bgSup,storageWithinTimestep[iCurrSup],timestep_internal); // see Trnsys manual 7.4.4.16.
					storageWithinTimestep[iCurrRet] = t299::solveDiffEqIntern_end(ag,bgRet,storageWithinTimestep[iCurrRet],timestep_internal); // return line next grout temperature
					logTime("grout temp solve");
				} // end of grout iteration
			// segment supply fluid temperature at the end and average over the timestep
			storageWithinTimestep[iSupTemp[iSeg]] = t299::solveDiffEqIntern_end(af,bfSup,storageWithinTimestep[iSupTemp[iSeg]],timestep_internal);
			// segment return fluid temperature at the end and average over the timestep
			storageWithinTimestep[iRetTemp[iSeg]] = t299::solveDiffEqIntern_end(af,bfRet,storageWithinTimestep[iRetTemp[iSeg]],timestep_internal);
			logTime("fluid temp solve.");

			if((iTimestep==n_timesteps_internal-1) && (iSeg==0))
			{	
				temp_out = t299::solveDiffEqIntern_ave(af,bfRet,storageWithinTimestep[iRetTemp[iSeg]],timestep_internal);
				logTime("fluid temp seg 0");
			}
		} // end of segment iteration (fluid & grout)
	} // end of sub-timestep iteration
	
	// ------------------------ LOAD AGGREGATION AND G-FUNCTION------------------------

	index = 1; // location of average wall temperature
	double q_currHTM = mflow_in*c_HTM*(temp_in-temp_out); // heat transferred from fluid to grout (W)
	double q_currPerLength = q_currHTM/n_BHE/l_BHE; // (W/m)
	
	if(iIteration==0)
	{
		loadAgg::next_time_step(q_b, A); // move to end of timestep?
		logTime("next load step");
	}
	loadAgg::set_current_load(q_b, q_currPerLength);
	logTime("set load");
	// TODO: currently g_Borefield needs to be read in at correct time values if read_gFuncFromFile!
	double deltaT = loadAgg::compute_deltaT(dg, q_b);
	double temp_wall = temp_undisturbed + deltaT; // Average wall temperature over all segments (K)

	logTime("wall temperature");

	for(int iSeg=0; iSeg<n_seg; iSeg++) // This can be later used for a depth resolved wall temp. distribution
		storageWithinTimestep[iTempWall[iSeg]] = temp_wall;

	// ------------------------ OUTPUTS ------------------------
	if(temp_out<=0)
		t299::message("Fatal","BHE outlet temperature reached absolute zero.");
	else if (temp_out>5000)
	{
		t299::message("Fatal","BHE outlet temperature is too high - "
		"unless your location is the sun.");
	}
	
	if(temp_wall<=0)
		t299::message("Fatal","BHE wall temperature reached absolute zero.");
	else if (temp_wall>5000)
	{
		t299::message("Fatal","BHE wall temperature is too high - "
		"unless your location is the sun.");
	}

	double tempOut_stupidUnits = temp_out - 273.15;
	double mflowIn_stupidUnits = mflow_in*3600;
	double tempWall_stupidUnits = temp_wall - 273.15;
	double qCurrHTM_stupidUnits = q_currHTM*3.6;
	index = 1; setOutputValue(&index, &tempOut_stupidUnits); // Outlet temperature (degC)
	index = 2; setOutputValue(&index, &mflowIn_stupidUnits); // Outlet mass flow rate (total) (kg/h)
	index = 3; setOutputValue(&index, &tempWall_stupidUnits); // Average wall temperature (degC)
	index = 4; setOutputValue(&index, &qCurrHTM_stupidUnits); // Average heat transfer rate (kJ/h)

	logTime("output values");

	return;
}
